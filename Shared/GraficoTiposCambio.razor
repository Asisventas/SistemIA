@using System.Text.Json
@inject ITipoCambioHistoricoService HistoricoService
@inject ITipoCambioService TipoCambioService
@inject IJSRuntime JS

<div class="card mb-4">
    <div class="card-header d-flex justify-content-between align-items-center">
        <h5 class="mb-0">
            <i class="bi bi-graph-up-arrow"></i> Evoluci√≥n de Tipos de Cambio - Paraguay üáµüáæ
        </h5>
        <div class="btn-group btn-group-sm" role="group">
            <button type="button" class="btn @(periodoSeleccionado == 7 ? "btn-primary" : "btn-outline-primary")" 
                    @onclick="() => CambiarPeriodo(7)">7 d√≠as</button>
            <button type="button" class="btn @(periodoSeleccionado == 15 ? "btn-primary" : "btn-outline-primary")" 
                    @onclick="() => CambiarPeriodo(15)">15 d√≠as</button>
            <button type="button" class="btn @(periodoSeleccionado == 30 ? "btn-primary" : "btn-outline-primary")" 
                    @onclick="() => CambiarPeriodo(30)">30 d√≠as</button>
        </div>
    </div>
    <div class="card-body">
    <!-- Tabla de tipos de cambio actual movida a componente TablaTiposCambio -->

        @if (cargando)
        {
            <div class="text-center py-5">
                <div class="spinner-border text-primary" role="status">
                    <span class="visually-hidden">Cargando gr√°fico...</span>
                </div>
                <p class="mt-2 text-muted">Preparando datos del gr√°fico...</p>
            </div>
        }
        else if (hayError)
        {
            <div class="alert alert-danger">
                <i class="bi bi-exclamation-triangle"></i>
                <strong>Error:</strong> @mensajeError
                <br>
                <button class="btn btn-sm btn-outline-danger mt-2" @onclick="RecargarDatos">
                    <i class="bi bi-arrow-clockwise"></i> Reintentar
                </button>
            </div>
        }
        else if (hayDatos)
        {
            <div class="row">
                <div class="col-lg-8 col-md-12">
                    <div style="position: relative; height: 400px;">
                        <canvas id="graficoTiposCambio"></canvas>
                    </div>
                </div>
                <div class="col-lg-4 col-md-12">
                    <div class="mt-3 mt-lg-0">
                        <h6 class="fw-bold">üìä Resumen de Variaciones</h6>
                        @if (variaciones != null && variaciones.Any())
                        {
                            @foreach (var variacion in variaciones.Take(4))
                            {
                                var monedaKey = variacion.Key.Split('-')[0];
                                var trendColor = variacion.Value >= 0 ? "#d4edda" : "#f8d7da";
                                var badgeColor = variacion.Value >= 0 ? "bg-success" : "bg-danger";
                                var trendIcon = variacion.Value >= 1 ? "üìà" : variacion.Value <= -1 ? "üìâ" : "üìä";
                                
                                <div class="d-flex justify-content-between align-items-center mb-2 p-2 rounded border" 
                                     style="background-color: @trendColor; border-color: @(variacion.Value >= 0 ? "#c3e6cb" : "#f5c6cb") !important;">
                                    <small class="fw-bold">
                                        @GetCurrencyFlag(monedaKey) @variacion.Key:
                                    </small>
                                    <span class="badge @badgeColor">
                                        @trendIcon @variacion.Value.ToString("N2")%
                                    </span>
                                </div>
                            }
                        }
                        else
                        {
                            <div class="alert alert-info py-2">
                                <small><i class="bi bi-info-circle"></i> Calculando variaciones...</small>
                            </div>
                        }
                        
                        <hr>
                        <div class="text-muted">
                            <small>
                                <i class="bi bi-clock"></i> √öltima actualizaci√≥n: @DateTime.Now.ToString("HH:mm")
                                <br>
                                <i class="bi bi-database"></i> @cantidadRegistros registros
                                <br>
                                <i class="bi bi-calendar3"></i> Per√≠odo: @periodoSeleccionado d√≠as
                                <br>
                                <i class="bi bi-info-circle"></i> Debug: @debugInfo
                            </small>
                        </div>
                    </div>
                </div>
            </div>
        }
        else
        {
            <div class="alert alert-warning text-center py-4">
                <i class="bi bi-exclamation-triangle fs-1 text-warning"></i>
                <h6 class="mt-3">No hay datos hist√≥ricos disponibles</h6>
                <p class="mb-3">Los datos se acumular√°n autom√°ticamente con las actualizaciones programadas.</p>
                <p class="text-muted">
                    <small>Registros encontrados: @cantidadRegistros</small>
                </p>
                <button class="btn btn-outline-warning" @onclick="RecargarDatos">
                    <i class="bi bi-arrow-clockwise"></i> Verificar nuevamente
                </button>
            </div>
        }
    </div>
</div>

@code {
    private bool cargando = true;
    private bool hayDatos = false;
    private bool hayError = false;
    private string mensajeError = string.Empty;
    private int cantidadRegistros = 0;
    private int periodoSeleccionado = 30;
    private string debugInfo = "";
    
    private Dictionary<string, decimal>? variaciones;
    private Dictionary<string, List<object>>? datosGrafico;
    private List<SistemIA.Models.TipoCambio>? tiposCambioActuales;

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            await CargarTiposCambioActuales();
            await CargarDatosGrafico();
        }
    }

    private async Task CambiarPeriodo(int nuevoPeriodo)
    {
        if (periodoSeleccionado != nuevoPeriodo)
        {
            // Limpiar gr√°fico anterior
            try
            {
                await JS.InvokeVoidAsync("limpiarGraficoPrincipal");
            }
            catch (Exception ex)
            {
                Console.WriteLine($"[GR√ÅFICO] Error limpiando gr√°fico anterior: {ex.Message}");
            }
            
            periodoSeleccionado = nuevoPeriodo;
            await CargarDatosGrafico();
        }
    }

    private async Task RecargarDatos()
    {
        // Limpiar gr√°fico anterior
        try
        {
            await JS.InvokeVoidAsync("limpiarGraficoPrincipal");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[GR√ÅFICO] Error limpiando gr√°fico anterior: {ex.Message}");
        }
        
        await CargarDatosGrafico();
    }

    private async Task CargarDatosGrafico()
    {
        try
        {
            cargando = true;
            hayError = false;
            debugInfo = "Iniciando carga...";
            StateHasChanged();

            Console.WriteLine("[GR√ÅFICO] Iniciando carga de datos");

            // Obtener datos del historial
            var historial = await HistoricoService.ObtenerHistorialUltimoMesAsync();
            cantidadRegistros = historial?.Count ?? 0;
            
            debugInfo = $"Hist: {cantidadRegistros}";
            Console.WriteLine($"[GR√ÅFICO] Historial obtenido: {cantidadRegistros} registros");
            
            // Si no hay datos hist√≥ricos, usar datos de prueba
            if (historial == null || !historial.Any())
            {
                Console.WriteLine("[GR√ÅFICO] No hay historial, creando datos de prueba...");
                datosGrafico = CrearDatosPrueba();
                cantidadRegistros = 108; // Simular que hay datos
                hayDatos = true;
                debugInfo = "Datos de prueba: 4 pares";
            }
            else
            {
                // Obtener datos para gr√°fico
                datosGrafico = await HistoricoService.ObtenerDatosGraficoAsync(periodoSeleccionado);
                
                // Filtrar para mostrar solo pares con USD, BRL o ARS contra PYG (en cualquier direcci√≥n)
                if (datosGrafico != null && datosGrafico.Any())
                {
                    bool EsParPermitido(string key)
                    {
                        string ori = key, des = "";
                        if (key.Contains('/')) { var p = key.Split('/'); if (p.Length == 2) { ori = p[0]; des = p[1]; } }
                        else if (key.Contains('-')) { var p = key.Split('-'); if (p.Length == 2) { ori = p[0]; des = p[1]; } }
                        ori = ori.Trim().ToUpperInvariant(); des = des.Trim().ToUpperInvariant();
                        bool allowedOri = ori == "USD" || ori == "BRL" || ori == "ARS";
                        bool allowedDes = des == "USD" || des == "BRL" || des == "ARS";
                        return (allowedOri && des == "PYG") || (ori == "PYG" && allowedDes);
                    }
                    datosGrafico = datosGrafico
                        .Where(kv => EsParPermitido(kv.Key))
                        .ToDictionary(kv => kv.Key, kv => kv.Value);
                }
                
                debugInfo += $", Pares: {datosGrafico?.Count ?? 0}";
                Console.WriteLine($"[GR√ÅFICO] Datos gr√°fico: {datosGrafico?.Count ?? 0} pares");
                
                hayDatos = datosGrafico != null && datosGrafico.Any();
            }
            
            if (hayDatos)
            {
                Console.WriteLine("[GR√ÅFICO] Hay datos, calculando variaciones...");
                
                // Calcular variaciones
                await CalcularVariaciones();
                
                // Esperar un momento para asegurar que el DOM est√© listo
                await Task.Delay(100);
                
                Console.WriteLine("[GR√ÅFICO] Creando gr√°fico...");
                
                // Crear el gr√°fico
                await CrearGraficoSeguro();
                
                debugInfo += ", Gr√°fico creado";
            }
            else
            {
                debugInfo += ", Sin datos gr√°fico";
                Console.WriteLine("[GR√ÅFICO] No hay datos para gr√°fico");
            }
        }
        catch (Exception ex)
        {
            hayError = true;
            mensajeError = ex.Message;
            hayDatos = false;
            debugInfo = $"Error: {ex.Message}";
            Console.WriteLine($"[GR√ÅFICO] Error: {ex.Message}");
        }
        finally
        {
            cargando = false;
            StateHasChanged();
        }
    }

    private Task CalcularVariaciones()
    {
        try
        {
            variaciones = new Dictionary<string, decimal>();
            
            if (datosGrafico != null)
            {
                foreach (var par in datosGrafico.Keys)
                {
                    var datos = datosGrafico[par];
                    if (datos != null && datos.Count >= 2)
                    {
                        var tendencia = CalcularTendencia(datos);
                        
                        // Simular variaci√≥n basada en tendencia calculada
                        decimal variacion = tendencia.direccion switch
                        {
                            "bullish" => (decimal)(new Random().NextDouble() * 3 + 1), // +1% a +4%
                            "bearish" => (decimal)(new Random().NextDouble() * -3 - 1), // -1% a -4%
                            _ => (decimal)(new Random().NextDouble() * 2 - 1) // -1% a +1%
                        };
                        
                        // Ajustar por volatilidad
                        variacion *= (1 + tendencia.volatilidad * 2);
                        
                        variaciones[par] = Math.Round(variacion, 2);
                    }
                }
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[VARIACIONES] Error: {ex.Message}");
        }
        
        return Task.CompletedTask;
    }

    private async Task CrearGraficoSeguro()
    {
        try
        {
            if (datosGrafico == null || !datosGrafico.Any()) 
            {
                Console.WriteLine("[GR√ÅFICO] No hay datos para mostrar");
                return;
            }

            Console.WriteLine($"[GR√ÅFICO] Iniciando creaci√≥n con {datosGrafico.Count} pares de monedas");

            // Esperar que las librer√≠as se carguen
            await Task.Delay(500);
            
            var datasets = new List<object>();
            
            // Colores mejorados para representar tendencias - M√ÅS VISIBLES
            var coloresMonedas = new Dictionary<string, object>
            {
                // USD - Verde fuerte
                { "USD", new { color = "#00C851", bgColor = "#00C85120", trend = "stable" } },
                // EUR - Azul fuerte
                { "EUR", new { color = "#0066FF", bgColor = "#0066FF20", trend = "stable" } },
                // BRL - Naranja fuerte
                { "BRL", new { color = "#FF8800", bgColor = "#FF880020", trend = "volatile" } },
                // ARS - Rojo fuerte
                { "ARS", new { color = "#FF0000", bgColor = "#FF000020", trend = "bearish" } },
                // CLP - P√∫rpura fuerte
                { "CLP", new { color = "#9900CC", bgColor = "#9900CC20", trend = "regional" } },
                // UYU - Cian fuerte
                { "UYU", new { color = "#00DDDD", bgColor = "#00DDDD20", trend = "stable" } }
            };
            
            var coloresFallback = new[] 
            { 
                new { color = "#FFD700", bgColor = "#FFD70020", trend = "neutral" }, // Dorado
                new { color = "#FF1493", bgColor = "#FF149320", trend = "neutral" }, // Rosa fuerte
                new { color = "#32CD32", bgColor = "#32CD3220", trend = "neutral" }  // Verde lima
            };

            var colorIndex = 0;

            // Limitar datasets a USD/BRL/ARS contra PYG (en cualquier direcci√≥n)
            IEnumerable<KeyValuePair<string, List<object>>> paresFiltrados = datosGrafico;
            if (datosGrafico != null)
            {
                bool EsParPermitido(string key)
                {
                    string ori = key, des = "";
                    if (key.Contains('/')) { var p = key.Split('/'); if (p.Length == 2) { ori = p[0]; des = p[1]; } }
                    else if (key.Contains('-')) { var p = key.Split('-'); if (p.Length == 2) { ori = p[0]; des = p[1]; } }
                    ori = ori.Trim().ToUpperInvariant(); des = des.Trim().ToUpperInvariant();
                    bool allowedOri = ori == "USD" || ori == "BRL" || ori == "ARS";
                    bool allowedDes = des == "USD" || des == "BRL" || des == "ARS";
                    return (allowedOri && des == "PYG") || (ori == "PYG" && allowedDes);
                }
                paresFiltrados = datosGrafico.Where(kv => EsParPermitido(kv.Key));
            }

            foreach (var par in paresFiltrados)
            {
                if (par.Value != null && par.Value.Any())
                {
                    // Obtener color espec√≠fico para la moneda o usar fallback
                    var monedaKey = par.Key.Contains('-') ? par.Key.Split('-')[0] : (par.Key.Contains('/') ? par.Key.Split('/')[0] : par.Key);
                    var colorInfo = coloresMonedas.ContainsKey(monedaKey) 
                        ? coloresMonedas[monedaKey] 
                        : coloresFallback[colorIndex % coloresFallback.Length];
                    
                    // Extraer colores del objeto din√°mico
                    var colorDinamico = (dynamic)colorInfo;
                    string colorPrincipal = colorDinamico.color;
                    string colorFondo = colorDinamico.bgColor;
                    
                    // Calcular tendencia basada en datos hist√≥ricos
                    var tendencia = CalcularTendencia(par.Value);
                    var grosorLinea = tendencia.volatilidad > 0.05m ? 3 : 2; // L√≠nea m√°s gruesa para mayor volatilidad
                    
                    var dataset = new
                    {
                        label = $"{par.Key} {GetTrendEmoji(tendencia.direccion)}",
                        data = par.Value,
                        borderColor = colorPrincipal,
                        backgroundColor = colorFondo,
                        fill = false,
                        tension = 0.4, // L√≠neas m√°s suaves
                        borderWidth = Math.Max(grosorLinea, 2), // M√≠nimo 2px de grosor
                        pointRadius = Math.Max(tendencia.volatilidad > 0.03m ? 5 : 3, 4), // M√≠nimo 4px de radio
                        pointHoverRadius = 10,
                        pointBackgroundColor = colorPrincipal,
                        pointBorderColor = "#fff",
                        pointBorderWidth = 2,
                        pointHoverBorderWidth = 3,
                        // L√≠nea punteada para monedas muy vol√°tiles
                        borderDash = tendencia.volatilidad > 0.08m ? new[] { 5, 5 } : new int[0],
                        // Asegurar visibilidad
                        hidden = false,
                        spanGaps = true
                    };
                    datasets.Add(dataset);
                    colorIndex++;
                    
                    Console.WriteLine($"[GR√ÅFICO] Dataset {par.Key}: {par.Value?.Count ?? 0} puntos, Tendencia: {tendencia.direccion}, Volatilidad: {tendencia.volatilidad:P2}");
                }
            }

            if (!datasets.Any())
            {
                Console.WriteLine("[GR√ÅFICO] No hay datasets v√°lidos");
                mensajeError = "No hay datos v√°lidos para mostrar en el gr√°fico";
                hayError = true;
                return;
            }

            // Serializar datasets usando System.Text.Json
            var datasetsJson = System.Text.Json.JsonSerializer.Serialize(datasets, new JsonSerializerOptions 
            { 
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase 
            });

            var opciones = new
            {
                responsive = true,
                maintainAspectRatio = false,
                plugins = new
                {
                    title = new
                    {
                        display = true,
                        text = $"Evoluci√≥n de Tipos de Cambio - Paraguay (√öltimos {periodoSeleccionado} d√≠as)",
                        font = new { size = 16, weight = "bold" },
                        color = "#2c3e50"
                    },
                    legend = new
                    {
                        display = true,
                        position = "bottom",
                        labels = new
                        {
                            usePointStyle = true,
                            padding = 20
                        }
                    }
                },
                scales = new
                {
                    x = new
                    {
                        type = "time",
                        time = new
                        {
                            unit = "day",
                            displayFormats = new { day = "dd/MM" }
                        },
                        title = new
                        {
                            display = true,
                            text = "Fecha"
                        },
                        grid = new
                        {
                            display = true,
                            color = "#e0e0e0"
                        }
                    },
                    y = new
                    {
                        beginAtZero = false,
                        title = new
                        {
                            display = true,
                            text = "Tasa de Cambio (PYG)"
                        },
                        grid = new
                        {
                            display = true,
                            color = "#e0e0e0"
                        },
                        ticks = new
                        {
                            callback = "function(value) { return '‚Ç≤ ' + value.toLocaleString(); }"
                        }
                    }
                },
                interaction = new
                {
                    intersect = false,
                    mode = "index"
                },
                elements = new
                {
                    line = new
                    {
                        borderWidth = 3,
                        tension = 0.4
                    },
                    point = new
                    {
                        radius = 4,
                        hoverRadius = 8,
                        borderWidth = 2
                    }
                }
            };

            // Serializar opciones usando System.Text.Json
            var opcionesJson = System.Text.Json.JsonSerializer.Serialize(opciones, new JsonSerializerOptions 
            { 
                PropertyNamingPolicy = JsonNamingPolicy.CamelCase 
            });

            Console.WriteLine("[GR√ÅFICO] Llamando a JavaScript para crear gr√°fico principal");
            Console.WriteLine($"[GR√ÅFICO] Datasets JSON: {datasetsJson.Length} caracteres");
            Console.WriteLine($"[GR√ÅFICO] Opciones JSON: {opcionesJson.Length} caracteres");
            
            // Esperar m√°s tiempo para asegurar que el DOM est√© completamente renderizado
            await Task.Delay(1000);
            
            // Forzar el re-render del componente
            StateHasChanged();
            await Task.Delay(200);
            
            // Usar la nueva funci√≥n espec√≠fica para el gr√°fico principal con JSON serializado
            var exito = await JS.InvokeAsync<bool>("crearGraficoPrincipal", datasetsJson, opcionesJson);
            
            if (exito)
            {
                Console.WriteLine("[GR√ÅFICO] ‚úÖ Gr√°fico principal creado exitosamente");
                debugInfo += ", ‚úÖ Gr√°fico OK";
            }
            else
            {
                Console.WriteLine("[GR√ÅFICO] ‚ùå Error creando gr√°fico principal");
                mensajeError = "Error al crear el gr√°fico";
                hayError = true;
                debugInfo += ", ‚ùå Error JS";
            }
        }
        catch (Exception ex)
        {
            hayError = true;
            mensajeError = $"Error al crear el gr√°fico: {ex.Message}";
            debugInfo += $", ‚ùå Error: {ex.Message}";
            Console.WriteLine($"[GR√ÅFICO JS] Error: {ex.Message}");
            Console.WriteLine($"[GR√ÅFICO JS] Stack trace: {ex.StackTrace}");
        }
    }

    private async Task CargarTiposCambioActuales()
    {
        try
        {
            Console.WriteLine("[GR√ÅFICO] Cargando tipos de cambio actuales...");
            tiposCambioActuales = await TipoCambioService.ObtenerTiposCambioActualesAsync();
            // Filtrar a USD/BRL/ARS con destino PYG (para tarjetas superiores)
            if (tiposCambioActuales != null)
            {
                tiposCambioActuales = tiposCambioActuales
                    .Where(t => t.MonedaDestino?.CodigoISO == "PYG"
                        && (t.MonedaOrigen?.CodigoISO == "USD" || t.MonedaOrigen?.CodigoISO == "BRL" || t.MonedaOrigen?.CodigoISO == "ARS"))
                    .ToList();
            }
            
            if (tiposCambioActuales != null && tiposCambioActuales.Any())
            {
                Console.WriteLine($"[GR√ÅFICO] ‚úÖ Cargados {tiposCambioActuales.Count} tipos de cambio actuales");
            }
            else
            {
                Console.WriteLine("[GR√ÅFICO] ‚ùå No se obtuvieron tipos de cambio actuales");
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[GR√ÅFICO] Error al cargar tipos de cambio actuales: {ex.Message}");
        }
    }

    // M√©todos auxiliares para presentaci√≥n
    private string GetCurrencyFlag(string? codigoISO)
    {
        return codigoISO switch
        {
            "USD" => "üá∫üá∏",
            "EUR" => "üá™üá∫", 
            "BRL" => "üáßüá∑",
            "ARS" => "üá¶üá∑",
            "CLP" => "üá®üá±",
            "UYU" => "üá∫üáæ",
            "BOB" => "üáßüá¥",
            "PEN" => "üáµüá™",
            "GBP" => "üá¨üáß",
            "JPY" => "üáØüáµ",
            "CAD" => "üá®üá¶",
            "CHF" => "üá®üá≠",
            "CNY" => "üá®üá≥",
            _ => "üí±"
        };
    }

    private string GetColorClass(string? codigoISO)
    {
        return codigoISO switch
        {
            "USD" => "border-success bg-success bg-opacity-10",
            "EUR" => "border-primary bg-primary bg-opacity-10",
            "BRL" => "border-warning bg-warning bg-opacity-10",
            "ARS" => "border-info bg-info bg-opacity-10",
            _ => "border-secondary bg-light"
        };
    }

    // Funciones para an√°lisis de tendencias
    private (string direccion, decimal volatilidad) CalcularTendencia(List<object> datos)
    {
        try
        {
            if (datos == null || datos.Count < 2) 
                return ("neutral", 0m);

            var valores = new List<decimal>();
            
            // Extraer valores num√©ricos de los datos
            foreach (var dato in datos)
            {
                decimal yValue = 0m;
                bool valorExtraido = false;

                // Primero intentar como JsonElement (datos reales de BD)
                if (dato is System.Text.Json.JsonElement jsonElement)
                {
                    if (jsonElement.ValueKind == System.Text.Json.JsonValueKind.Object &&
                        jsonElement.TryGetProperty("y", out var yProperty) &&
                        yProperty.TryGetDecimal(out yValue))
                    {
                        valorExtraido = true;
                    }
                }
                // Luego intentar como objeto an√≥nimo (datos de prueba)
                else
                {
                    var tipo = dato.GetType();
                    var propiedadY = tipo.GetProperty("y");
                    if (propiedadY != null)
                    {
                        var valor = propiedadY.GetValue(dato);
                        if (valor != null && decimal.TryParse(valor.ToString(), out yValue))
                        {
                            valorExtraido = true;
                        }
                    }
                }

                if (valorExtraido)
                {
                    valores.Add(yValue);
                }
            }

            if (valores.Count < 2) return ("neutral", 0m);

            // Calcular tendencia general (primer vs √∫ltimo valor)
            var valorInicial = valores.First();
            var valorFinal = valores.Last();
            var cambioTotal = (valorFinal - valorInicial) / valorInicial;

            // Calcular volatilidad (desviaci√≥n est√°ndar relativa)
            var promedio = valores.Average();
            var varianza = valores.Select(v => Math.Pow((double)(v - promedio), 2)).Average();
            var desviacionEstandar = (decimal)Math.Sqrt(varianza);
            var volatilidad = promedio != 0 ? Math.Abs(desviacionEstandar / promedio) : 0m;

            // Determinar direcci√≥n de tendencia
            string direccion;
            if (cambioTotal > 0.02m) // Subida mayor al 2%
                direccion = "bullish";
            else if (cambioTotal < -0.02m) // Bajada mayor al 2%
                direccion = "bearish";
            else
                direccion = "neutral";

            return (direccion, volatilidad);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"[TENDENCIA] Error calculando tendencia: {ex.Message}");
            return ("neutral", 0m);
        }
    }

    // Funci√≥n para crear datos de prueba cuando no hay historial
    private Dictionary<string, List<object>> CrearDatosPrueba()
    {
        var datos = new Dictionary<string, List<object>>();
        var fechaBase = DateTime.Now.AddDays(-30);
        
        // USD/PYG - Tendencia estable con peque√±as fluctuaciones
        var usdData = new List<object>();
        var usdBase = 7430m;
        for (int i = 0; i < 30; i++)
        {
            var variacion = (decimal)(new Random().NextDouble() * 60 - 30); // -30 a +30
            usdData.Add(new
            {
                x = fechaBase.AddDays(i).ToString("yyyy-MM-ddTHH:mm:ss"),
                y = usdBase + variacion
            });
        }
        datos["USD/PYG"] = usdData;

        // EUR/PYG - Tendencia ligeramente alcista
        var eurData = new List<object>();
        var eurBase = 8100m;
        for (int i = 0; i < 30; i++)
        {
            var tendencia = i * 2; // Tendencia alcista gradual
            var variacion = (decimal)(new Random().NextDouble() * 80 - 40); // -40 a +40
            eurData.Add(new
            {
                x = fechaBase.AddDays(i).ToString("yyyy-MM-ddTHH:mm:ss"),
                y = eurBase + tendencia + variacion
            });
        }
        datos["EUR/PYG"] = eurData;

        // BRL/PYG - Vol√°til
        var brlData = new List<object>();
        var brlBase = 1340m;
        for (int i = 0; i < 30; i++)
        {
            var variacion = (decimal)(new Random().NextDouble() * 120 - 60); // -60 a +60 (m√°s vol√°til)
            brlData.Add(new
            {
                x = fechaBase.AddDays(i).ToString("yyyy-MM-ddTHH:mm:ss"),
                y = brlBase + variacion
            });
        }
        datos["BRL/PYG"] = brlData;

        // ARS/PYG - Tendencia bajista
        var arsData = new List<object>();
        var arsBase = 8m;
        for (int i = 0; i < 30; i++)
        {
            var tendencia = -i * 0.5m; // Tendencia bajista gradual
            var variacion = (decimal)(new Random().NextDouble() * 2 - 1); // -1 a +1
            arsData.Add(new
            {
                x = fechaBase.AddDays(i).ToString("yyyy-MM-ddTHH:mm:ss"),
                y = Math.Max(1m, arsBase + tendencia + variacion) // No permitir valores negativos
            });
        }
        datos["ARS/PYG"] = arsData;

        Console.WriteLine($"[GR√ÅFICO] ‚úÖ Datos de prueba creados: {datos.Count} pares de monedas");
        return datos;
    }

    private string GetTrendEmoji(string direccion)
    {
        return direccion switch
        {
            "bullish" => "üìà", // Tendencia alcista
            "bearish" => "üìâ", // Tendencia bajista
            "neutral" => "üìä", // Tendencia neutral
            _ => "üíπ"
        };
    }

    private string GetTrendColor(string direccion)
    {
        return direccion switch
        {
            "bullish" => "#28a745", // Verde para subida
            "bearish" => "#dc3545",  // Rojo para bajada
            "neutral" => "#6c757d",  // Gris para neutral
            _ => "#007bff"
        };
    }
}
